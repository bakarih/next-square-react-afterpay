"use strict";
/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateUserAgent = exports.deprecated = exports.isBlob = exports.sanitizeUrl = void 0;
var tslib_1 = require("tslib");
var detect_browser_1 = require("detect-browser");
var tiny_warning_1 = tslib_1.__importDefault(require("tiny-warning"));
/**
 * Validates the protocol and removes duplicate forward slashes
 *
 * @param url URL to clean
 * @returns Sanitized URL
 */
function sanitizeUrl(url) {
    // ensure that the urls are absolute
    var protocolRegex = /^https?:\/\/[^/]+/;
    var match = url.match(protocolRegex);
    if (match === null) {
        throw new Error("Invalid URL format: " + url);
    }
    // remove redundant double-forward slashes
    var protocol = match[0];
    var queryUrl = url.substring(protocol.length).replace(/\/\/+/g, '/');
    return protocol + queryUrl;
}
exports.sanitizeUrl = sanitizeUrl;
/**
 * Check whether value is an instance of Blob
 *
 * @remark
 * Reference: https://github.com/sindresorhus/is-blob/blob/master/index.js
 *
 * @param value Value to check
 * @returns True if the value is a Blob instance
 */
function isBlob(value) {
    if (typeof Blob === 'undefined') {
        return false;
    }
    return (value instanceof Blob ||
        Object.prototype.toString.call(value) === '[object Blob]');
}
exports.isBlob = isBlob;
// This is used by deprecated() to keep track of "hits".
var deprecatedHits = {};
/**
 * Create warning for deprecated method usage.
 *
 * This is called once per deprecated method. If this method is called again
 * with the same arguments, no warning is generated.
 *
 * @param methodName Method name for deprecated method
 * @param notice Optional message for deprecation
 */
function deprecated(methodName, notice) {
    var message = "Method " + methodName + " is deprecated.";
    if (notice) {
        message += " " + notice;
    }
    if (deprecatedHits[message]) {
        return;
    }
    deprecatedHits[message] = true;
    if (process.env.NODE_ENV !== 'production') {
        tiny_warning_1.default(false, message);
    }
}
exports.deprecated = deprecated;
/**
 * Replace the templated placeholders in user-agent with the platform
 * related information.
 * @param userAgent User-agent value to be updated
 * @returns Updated user-agent value
 */
function updateUserAgent(userAgent, apiVersion, detail) {
    var updatedAgent = userAgent;
    var result = detect_browser_1.detect();
    if (result) {
        updatedAgent = updatedAgent.replace('{engine}', result.name);
    }
    if (result === null || result === void 0 ? void 0 : result.version) {
        updatedAgent = updatedAgent.replace('{engine-version}', result.version);
    }
    if (result === null || result === void 0 ? void 0 : result.os) {
        updatedAgent = updatedAgent.replace('{os-info}', result.os);
    }
    if (typeof apiVersion !== 'undefined') {
        updatedAgent = updatedAgent.replace('{api-version}', apiVersion);
    }
    if (typeof detail !== 'undefined') {
        assertUserAgentDetail(detail);
        updatedAgent = updatedAgent.replace('{detail}', encodeURIComponent(detail));
    }
    return updatedAgent;
}
exports.updateUserAgent = updateUserAgent;
function assertUserAgentDetail(detail) {
    if (detail.length > 128) {
        throw new Error('userAgentDetail length exceeds 128 characters limit');
    }
}
