import { __values, __spreadArray, __read } from 'tslib';
import { isFileWrapper, cloneFileWrapper } from '../fileWrapper.js';
/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

/**
 * Array prefix format: item[1]=1&item[2]=2
 */

var indexedPrefix = function (prefix, key) {
  return prefix + "[" + key + "]";
};
/**
 * Converts an object to a list of key-value pairs for form-urlencoded serialization.
 *
 * @param obj The object to serialize
 * @param prefixFormat Formatting function to create key for nested arrays
 * @return Result of serialization
 */


function formDataEncodeObject(obj, prefixFormat) {
  var e_1, _a, _b, _c;

  if (prefixFormat === void 0) {
    prefixFormat = indexedPrefix;
  }

  var result = [];

  try {
    for (var _d = __values(Object.keys(obj)), _e = _d.next(); !_e.done; _e = _d.next()) {
      var key = _e.value;
      var value = obj[key];

      if (value === null || value === undefined) {
        continue;
      } else if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') {
        result.push({
          key: key,
          value: value.toString()
        });
      } else if (isFileWrapper(value)) {
        result.push({
          key: key,
          value: cloneFileWrapper(value)
        });
      } else if (Array.isArray(value)) {
        for (var iter = 0; iter < value.length; iter += 1) {
          result.push.apply(result, __spreadArray([], __read(formDataEncodeObject((_b = {}, _b[prefixFormat(key, iter)] = value[iter], _b)))));
        }
      } else if (typeof value === 'object') {
        for (var objectKey in value) {
          if (Object.prototype.hasOwnProperty.call(value, objectKey)) {
            var element = value[objectKey];
            result.push.apply(result, __spreadArray([], __read(formDataEncodeObject((_c = {}, _c[indexedPrefix(key, objectKey)] = element, _c)))));
          }
        }
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return result;
}
/**
 * Return a new list with all key-value pairs, which have a FileWrapper as value, removed
 *
 * @param params List of key-value pairs
 */


function filterFileWrapperFromKeyValuePairs(params) {
  return params.filter(function (p) {
    return !isFileWrapper(p.value);
  });
}
/**
 * Serializes an object for a form-urlencoded request.
 *
 * Nested and complex types in values will be flattened using {@link formDataEncodeObject() function} method.
 *
 * @param  obj The object to be serialized
 * @return The result of serialization
 */


function urlEncodeObject(obj) {
  var params = formDataEncodeObject(obj);
  return urlEncodeKeyValuePairs(params);
}
/**
 * Serializes a list of key-value pairs for a form-urlencoded request.
 *
 * @param params List of key-value pairs to serialize
 * @return The result of serialization
 */


function urlEncodeKeyValuePairs(params) {
  var encode = encodeURIComponent;
  return (params || []).map(function (p) {
    return encode(p.key) + "=" + encode(p.value.toString());
  }).join('&');
}

export { filterFileWrapperFromKeyValuePairs, formDataEncodeObject, indexedPrefix, urlEncodeKeyValuePairs, urlEncodeObject };